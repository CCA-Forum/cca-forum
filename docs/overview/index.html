
<map name="forummap">
<!-- #$-:Image Map file created by GIMP Imagemap Plugin -->
<!-- #$-:GIMP Imagemap Plugin by Maurits Rijk -->
<!-- #$-:Please do not edit lines starting with "#$" -->
<!-- #:1.4 -->
<!-- #:rob -->
<area shape="circle" coords="19,19,19" href="../yellow_window/index.html" />
</map>

<html>

<head>

<title>The Common Component Architecture Forum</title>

<link rel="shortcut icon" href="../db/images/cca_logo.ico">
<style>
body,td           { font-family: Verdana,Geneva,Arial,Sans-serif; 
                    font-size: 11pt; color: #333333; }
a                 { color: #000000 }
.pagetitle        { font-size: 20pt; font-weight: bold; color: #336699; }
.dateheader       { font-size: 12pt; font-weight: bold; color: #ffffff; }
.sidebartitle     { font-size: 12pt; font-weight: bold; color: #ffffff; }
.storytitle       { font-size: 13pt; font-weight: bold; color: #336699; }
.substorytitle    { font-size: 11pt; font-weight: bold; color: #336699; }
.small            { font-size: 10pt; }
</style>

</head>

<body background="../db/images/cca_logo.png">

<table border="0" width="100%" cellpadding="0" cellspacing="0">
 <tr>
  <!-- main logo -->
  <td colspan="2">
  <img src="../db/images/cca-logo-trans-180.gif" usemap="#forummap" alt="cca logo" border="0">
  </td>

  <td><nobr>&nbsp; </nobr></td>
  <td><nobr>&nbsp; </nobr></td>

  <!-- main title -->
  <td colspan="2">
  <span class="pagetitle">The Common Component Architecture Forum</span>
  </td>
 </tr>

 <!-- Division between logo/title and breadcrumbs -->
 <tr>
  <td colspan="6" height="4" ></td>
 </tr>
 <tr>
  <td colspan="6" bgcolor="#000000" height="2" ></td>
 </tr>
 <tr>
  <td colspan="6" height="4" ></td>
 </tr>
 
 <!-- Breadcrumbs -->
 <tr>
 <td colspan="6"><span class=small> <div class="breadcrumb">
<a href="http://www.cca-forum.org/index.html">Main</a>
::
<span class="breadcrumb-this">Overview</span></div>
 </span></td>
 </tr>

 <!-- Some space between breadcrumbs and main area -->
 <tr><td>&nbsp;</td></tr>

 <!-- Main area -->
 <tr valign="top">

  <!-- left margin -->
  <td><nobr>&nbsp;</nobr></td>

  <!-- left column -->
  <td>
  <table width="100%" noshade="" cellspacing=0>

   <!-- Quick Links -->
   <tr>
   <td bgcolor="#336699" class=sidebartitle>Quick Links</td>
   </tr>
   <tr>
   <td>
   <a href="http://www.cca-forum.org/index.html">Main</a><br>
&nbsp;&nbsp;<a href="../components/index.html">Components</a><br>
&nbsp;&nbsp;<a href="../contacts/index.html">Contacts</a><br>
&nbsp;&nbsp;<a href="../docs/index.html">Docs</a><br>
&nbsp;&nbsp;<a href="../glossary/index.html">Glossary</a><br>
&nbsp;&nbsp;<a href="../groups/index.html">Groups</a><br>
&nbsp;&nbsp;<a href="../help/index.html">Help</a><br>
&nbsp;&nbsp;<a href="../meetings/index.html">Meetings</a><br>
&nbsp;&nbsp;<a href="../members/index.html">Members</a><br>
&nbsp;&nbsp;<a href="../news/index.html">News</a><br>
&nbsp;&nbsp;<b>Overview</b><br>
&nbsp;&nbsp;<a href="../scidac/index.html">Scidac</a><br>
&nbsp;&nbsp;<a href="../software/index.html">Software</a><br>

   &nbsp;&nbsp;<a href="../mailman/listinfo.1.html">Mailing Lists</a><br>
   &nbsp;&nbsp;<a href="../toolkit/index.html">Toolkit</a><br>
   &nbsp;&nbsp;<a href="../tutorials.1.html">Tutorials</a><br>
   </td></tr>
   <tr><td>&nbsp;</td></tr>

   <!-- Search Form -->
   <tr>
   <td bgcolor="#336699" class=sidebartitle>Search</td>
   </tr>
   <tr><td>
   <form method="get" action="http://www.cca-forum.org/index.find">
	<div>
		<input type="text" name="find" size="15" value=""/>
		<input type="submit" value="Search" />
		<input type="hidden" name="plugin" value="find"/>
		<input type="hidden" name="path" value="overview"/>
		<br/>
		<a href="index.html%3Fadvanced_search=1.html">Advanced Search</a>

</div></form>
   </td></tr>
   <tr><td>&nbsp;</td></tr>

   <!-- About Message -->
   <tr>
   <td bgcolor="#336699" class=sidebartitle>About</td>
   </tr>
   <tr><td>
   The CCA Forum is a group committed to defining a standard component
   architecture for high performance computing.  Please email the
   <a href="mailto:webmaster@cca-forum.org">webmaster</a>
   for suggestions about this site.
   </td></tr>
   <tr><td>&nbsp;</td></tr>

   <!-- Blosxom Signature -->
   <tr><td>
   <a href="http://www.blosxom.com/">
   <img src="http://www.blosxom.com/images/pb_blosxom.gif" border="1" hspace="3" vspace="3" />
   </a>
   </td></tr>

  </table>

  </td>

  <!-- Spacing between left column and main column -->
  <td><nobr>&nbsp; </nobr></td>
  <td><nobr>&nbsp; </nobr></td> 

  <!-- main blog entry column -->
  <td width="100%"> 

  

<p>
<span class="storytitle">Overview</span>
<br />

<p>

The Common Component Architecture (CCA) Forum is a group of
researchers from national labs and academic institutions commited to
defining a standard component architecture for high performance
computing.

</p>
</p>
<p>
<span class="storytitle">Component Programming Model</span>
<br />

<p>

Traditionally, high-performance scientific applications are assembled
from large blocks of hand-crafted code into monolithic applications.
Software reuse is obtained by linking with software libraries obtained
either from third parties, or created in house, from scratch.  A major
disadvantage of this approach is that software boundaries (function
interfaces and global symbols) are frequently not well thought out.
This can lead to internal code dependencies which make the monolithic
application difficult to modify and to maintain.  Unfortunately, in
this regard, scientific software must be frequently modified in order
to perform the next model run or scientific study.

</p>

<p>

Components, on the other hand, are designed with standard, clearly
defined interfaces which tend to protect them from changes in the
software environment outside their boundaries.  Applications are
composed (assembled) at run-time from components selected from a
component pool.  Because components communicate only through
well-defined interfaces, when an application needs to be modified, a
single component can be modified (or exchanged for a similar
component), without fear of disturbing the other components making up
the application.

</p>

<p>

The component programming model is the end of a natural progression,
starting from the monolithic application, and moving toward
applications built from increasingly more modularized pieces, with
<tt>one addition,</tt> the framework.

</p>
</p>
<p>
<span class="storytitle">Framework</span>
<br />

<p>

The framework provides the glue that binds components together.  It is
used to compose (combine) separate components from a component pool
into a running application.  It allows components to be linked
together and to make calls on specific component interfaces.
Additionally, the framework can provide information about the run-time
environment.

</p>
</p>
<p>
<span class="storytitle">Putting It All Together</span>
<br />

<p>
The picture below depicts the elements of the CCA standard and their
relationships.  The elements with gray background depict elements
pertaining to a specific implementation of a component
architecture. As outlined in the <a href="../glossary.html">CCA Component
Architecture Model</a>, such elements can include a communication
framework, a builder, a repository or individual components. The
elements with white background depict elements of the CCA standards
necessary for component-level interoperability of components developed
within different frameworks.
</p>

<p>
As shown in the picture components interact with each other, and
with a specific framework implementation through standard CCA
interfaces.  Each component defines its inputs and outputs in
<B>Scientific IDL</B>; these definitions are deposited in, and can be
retrieved from a repository by using the <b>CCA Repository API</b>.
In addition, these definitions serve as input to a proxy generator
which generates <b>component stubs</b>: the component-specific
parts of GPorts (white box in the picture). The components can also
use framework services directly through the <b>CCA Framework Services</b>
Interface.  The <b>CCA Configuration API</b> ensures that the the
components can collaborate with different builders associated with
different frameworks.
</p>

<p>
A framework which conforms to those standards, ie. provides the
required CCA services, can express component functionality in
scientific IDL, and implements the required CCA interfaces is <b>CCA
compliant</b>. Different components will require different sets of
services to interoperate; for example some may require remote
communication while some don't. Because of this the CCA standard will
define different degrees or flavors of compliance; each component will
specify a minimum degree of compliance required of a framework within
which it can interact.
</p>

<center>
<img src="../db/images/overview_big_picture.gif"/>
</center>

<p>
We will now describe the elements of the CCA standard in more detail:
<br/> 

<ul>
<li>
<b>CCA Scientific IDL</b> describes the input and output types of components
as well as their relationships. This part of the architecture is needed
to provide and share component descriptions across different framework
implementations. Component descriptions are deposited, and can be retrieved
from the Repository through the CCA Repository Interface (see below). Furthermore,
component descriptions are used by the proxy generator to provide the "component
stubs" element of Gports.
</li>

<li>
<b>Gports</b> are a CCA standard encompassing all the functionality necessary
to organize component interactions within any CCA compliant framework.
The purpose of this standard is to define a uniform model of CCA component
interaction. There are two parts to Gports:
</li>

<ul>
<li>
A library of general, framework-specific, but component-independent functionality
pertaining to component interaction; this includes such functionality as
for example adding a listener to an object, and has the same interface
for every component.
</li>

<li>
Code implementing component-specific, but framework-independent functionality;
it is generated by a proxy generator based on the component definition
expressed in CCA Scientific IDL, and will be referred to as a component
stub. A component stub contains for example an implementation of an output
port, the implementation of marshaling functions in a distributed environment,
and provides meta-services such as introspection. The component stub is
implemented in terms of standard CCA Framework Services which makes the
stub framework-independent. Furthermore, a component stub is expressed
in terms of a mapping from the CCA Scientific IDL to a particular language
or framework of implementation of the component (for example C++, C, Fortran,
Java).
</li>
</ul>

<li>
<b>CCA Framework Services</b> present a framework abstraction which can
be used in the component stub implementation as well as by the components
themselves directly. This element of architecture is needed for two reasons:
in order to abstract certain services which may be used by components directly,
and in order to standardize the implementation of component stubs. Furthermore
specifying CCA framework services provides a clear definition of the services
a CCA framework needs to implement in order to to be CCA compliant, in
other words ensure a common platform to components. The following services
have been identified so far: communication, security, thread creation and
management, memory management and error handling.
</li>

<li>
<b>CCA Configuration API</b> encompasses the functionality necessary
for the component to interact with the builder and vice versa. This includes
such functions as notifying components that they are added to a scenario
or deleted from it, redirecting interactions between components. or notifying
the builder of a component failure.
</li>

<li>
<b>CCA Repository API</b> defines the functionality necessary to search
a framework repository for components (as defined in CCA scientific IDL),
as well as manipulate components within the repository.
</li>

</ul>
</p>

</p>
<p>
<span class="storytitle">Motivation</span>
<br />

<p>
The idea of using component frameworks to deal with the complexity of
developing interdisciplinary HPC applications is becoming increasingly
popular. Such systems enable programmers to accelerate project development
through introducing higher-level abstractions and allowing code
reusability, as well as provide clearly specified component interfaces
which facilitate the task of team interaction. These potential benefits
encouraged research groups within a number of laboratories and universities
to develop, and experiment with prototype systems. Consequently, there is a
need for an interoperability standard. 
</p>

<p>
The need for component programming has been recognized by the business
world and resulted in the development of systems such as CORBA, DCOM,
Active X and others. However, these systems were designed primarily for
sequential applications and do not address the needs of HPC. Their most
important shortcoming from the point of view of HPC is that they don't
support abstractions necessary for high-performance programming, and don't
stress enough what is often the most important factor in scientific
programming: performance. In addition, the existing systems are often
invasive, that is, they require substantial modifications to existing
applications which may not be acceptable to the developer of
high-performance components. 
</p>

<p>
In view of these problems it is critical to develop a standard which will
address specifically the needs of HPC community. It is our hope that a
clear understanding of our needs, and an exploration of our possibilities
will result in a system enabling faster and more efficient programming in
the future.
</p>
</p>
<p>
<span class="storytitle">Advantages</span>
<br />

<p>
Component programming offers many advantages over the conventional
programming model based on subroutines. The most important are:
</p>

<ul>

<li>
Components provide <b>a clear specification of the inputs</b>
needed from other components or elements of the system.
</li>

<li>
Well-designed components have the potential for <b>encapsulating
parallelism better</b> than simple procedure calls.
</li>

<li>
A multi-component application allows for the <b>integration of
components implemented in different languages</b>.
</li>

<li>
Components <b>may have state</b>.
</li>

<li>
Components can be replaced, added to or deleted from an application
at run-time via <b>dynamic linking</b>.  Component interchangeablity
enables graceful software evolution, as you can substitue one
conponent with another, more efficient one.
</li>

<li>
Components <b>can be customized</b> at the time an application
is built through configuration parameters or properties.
</li>

<li>
A component <b>may have multiple different interfaces</b>.
</li>

<li>
A component <b>can be easily moved to a remote location</b>
without recompiling other parts of the application, in particular
other components that interact with it directly.
</li>

<li>
If a call does not need return values, component programming
allows for <b>multicasting such calls</b>.
</li>

</ul>

</p>
<br />

  </td>

  <td><nobr>&nbsp; </nobr>

 </tr>

 <tr>

  <td colspan="6" bgcolor="#000000" height="1"></td> 

 </tr>

 <tr>

  <td colspan="6" align="right">&copy Copyright 2002-2004 <a href="http://www.cca-forum.org/"CCA Forum</a></td>

 <tr>

</table>

</body>

</html>

